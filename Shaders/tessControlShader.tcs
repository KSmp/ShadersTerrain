// first step of tesselation shader
// tesselation control shader add/deletes control points and determines the tesselatation level
// patch has three control points here (three vertices for each triangle)


#version 450 core
layout (vertices = 3) out;

float GetTessLevel(float viewPos, float fragPos);

// vectors stored as arrays - each patch has three vertices, each with an xyz pos and xyz norm value 
//posVS = position from Vertex Shader, posTC = position from this Tesselation Control shader

in vec3 posVS[] ;
// in vec3 normVS[] ;

out vec3 posTC[] ;
// out vec3 normTC[] ;

uniform vec3 viewPos;
uniform bool stepTessOn;
uniform bool linearTessOn;
uniform bool expoTessOn;

void main()
{

  // tesselation level; we will find this automatically later but for now hardcoded value
   int tessLevel = 2;

   // gpu can calculate each control point in parallel
   // tesselation level same for entire patch so only need to set it once (for the first control point)
   // gl_invocation called for each control point
   if (gl_InvocationID==0)
   {
		// Calculate the tessellation levels

        const int vertNum = 3;
        float cameraToVertexDist[vertNum];

        for (int i = 0; i < vertNum; i++) {
            cameraToVertexDist[i] = distance(viewPos, posVS[i]);
        }

        for (int i = 0; i < vertNum - 1; i++) {
            gl_TessLevelOuter[i] = GetTessLevel(cameraToVertexDist[i], cameraToVertexDist[i + 1]);
        }
            
            gl_TessLevelOuter[vertNum - 1] = GetTessLevel(cameraToVertexDist[vertNum - 1], cameraToVertexDist[0]);
            gl_TessLevelInner[0] = tessLevel ; 

   }

   // pass through position and normal information
   posTC[gl_InvocationID]  = posVS[gl_InvocationID] ;
   // normTC[gl_InvocationID] = normVS[gl_InvocationID] ;
}

float GetTessLevel(float dist1, float dist2) {
    float avg = (dist1 + dist2) / 2.0;

    if (stepTessOn) {
            if (avg < 5) {
                return 10;
            } else if (avg < 10) {
                return 5;
            } if (avg < 15) {
                return 2;
            } else {
                return 1;
            }
    }

    if (linearTessOn) {
        float a = 10.0;
        float b = -0.5;

        float result = a + b * avg;
        
        if (result > 1.0) {
            return result;
        }

        return 1;
    }

    if (expoTessOn) {
        //float c = 10.0;
        //float e = 2.718;
        //float k = 0.0025;

        //return c * pow(e, -avg) * k;

        float a = 0.8;
        float k = 100.0;
        return pow(a, avg) * k;
    }

    return 1;
}